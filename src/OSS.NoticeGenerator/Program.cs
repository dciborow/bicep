// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using OSS.NoticeGenerator.Models;
using System.Collections.Immutable;
using System.CommandLine;
using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Text.Json;
using System.Net;

namespace OSS.NoticeGenerator
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("ApiDesign", "RS0030:Do not used banned APIs", Justification = "Ok to write to StdOut in this app.")]
    public class Program
    {
        private static readonly JsonSerializerOptions SerializerOptions = new()
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = true
        };

        public static async Task<int> Main(string[] args)
        {
            var rootCommand = new RootCommand("Third-party notice generator");

            var assetFilesOption = new Option<List<string>>("--asset-files", "One or more paths to project.assets.json file(s).")
            {
                Arity = ArgumentArity.ZeroOrMore,
                AllowMultipleArgumentsPerToken = true,
                IsRequired = false
            };

            var npmListJsonFilesOption = new Option<List<string>>("--npm-list-json-files", "One or more paths to files generated by the 'npm list -a --json' command.")
            {
                Arity = ArgumentArity.ZeroOrMore,
                AllowMultipleArgumentsPerToken = true,
                IsRequired = false
            };

            var outputOption = new Option<string>("--output-file", "Path where the generated NOTICE file will be saved.")
            {
                IsRequired = true
            };

            rootCommand.AddOption(assetFilesOption);
            rootCommand.AddOption(npmListJsonFilesOption);
            rootCommand.AddOption(outputOption);

            try
            {
                rootCommand.SetHandler<List<string>, List<string>, string>(async (assetFiles, npmListJsonFiles, outputFile) =>
                {
                    await MainInternal(
                        assetFiles.Select(ResolvePath).ToImmutableArray(),
                        npmListJsonFiles.Select(ResolvePath).ToImmutableArray(),
                        ResolvePath(outputFile));
                }, assetFilesOption, npmListJsonFilesOption, outputOption);

                return await rootCommand.InvokeAsync(args);
            }
            catch(ApplicationException exception)
            {
                Console.Error.WriteLine(exception.Message);
                return 1;
            }
        }

        private static async Task MainInternal(ImmutableArray<string> assetFiles, ImmutableArray<string> npmListJsonFiles, string outputFile)
        {
            var nugetDependencies = assetFiles
                .Select(assetFilePath => DeserializeFile<ProjectAssetsFile>(assetFilePath))
                .SelectMany(assetFile => assetFile.Libraries.Values)
                .Select(library => library.Path)
                .Distinct()
                .ToImmutableArray();

            Console.WriteLine($"NuGet dependencies ({nugetDependencies.Length}):");
            foreach (var nugetDependency in nugetDependencies)
            {
                Console.WriteLine($"  {nugetDependency}");
            }

            var npmDependencies = npmListJsonFiles
                .Select(npmListJsonFile => DeserializeFile<NpmListJsonFile>(npmListJsonFile))
                .SelectMany(file => SelectAllDependencies(file))
                .Distinct()
                .ToImmutableArray();
            Console.WriteLine($"NPM dependencies ({npmDependencies.Length}):");
            foreach (var npmDependency in npmDependencies)
            {
                Console.WriteLine($"  {npmDependency}");
            }

            var client = new HttpClient();
            client.DefaultRequestHeaders.Accept.Clear();
            client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

            var requestBody = CreateNoticeRequest(nugetDependencies, npmDependencies);
            var responseBody = await GenerateNotice(client, requestBody);

            Console.WriteLine($"Generated {responseBody.Content.Length} characters of NOTICE file.");
            File.WriteAllText(outputFile, responseBody.Content);

            Console.WriteLine($"NOTICE file saved to '{outputFile}'.");
        }

        private static string ResolvePath(string path)
        {
            if (Path.IsPathFullyQualified(path))
            {
                return path;
            }

            return Path.Combine(Environment.CurrentDirectory, path);
        }

        private static T DeserializeFile<T>(string assetFile)
        {
            using var stream = File.OpenRead(assetFile);
            return JsonSerializer.Deserialize<T>(stream, SerializerOptions) ?? throw new Exception($"Unable to deserialize file '{assetFile}'.");
        }

        private static IEnumerable<string>SelectAllDependencies(NpmListJsonFile file)
        {
            static string FormatPath(string name, string version) => $"{name}/{version}";

            static IEnumerable<string> SelectAllDependencyPaths(ImmutableDictionary<string, NpmListJsonFileDependency>? dependencies)
            {
                foreach (var kvp in dependencies ?? ImmutableDictionary<string, NpmListJsonFileDependency>.Empty)
                {
                    yield return FormatPath(kvp.Key, kvp.Value.Version);

                    foreach(var subDependencyPath in SelectAllDependencyPaths(kvp.Value.Dependencies))
                    {
                        yield return subDependencyPath;
                    }
                }
            }

            yield return FormatPath(file.Name, file.Version);
            foreach (var path in SelectAllDependencyPaths(file.Dependencies))
            {
                yield return path;
            }            
        }

        private static NoticeRequest CreateNoticeRequest(IEnumerable<string> nugetDependencies, IEnumerable<string> npmDependencies)
        {
            var coordinates = nugetDependencies
                .Select(nugetDependency => $"nuget/nuget/-/{nugetDependency}")
                .Concat(npmDependencies.Select(npmDependency => $"npm/npmjs/-/{npmDependency}"))
                .ToImmutableArray();

            return new NoticeRequest(coordinates, new NoticeRequestOptions());
        }

        private static async Task<NoticeResponse> GenerateNotice(HttpClient client, NoticeRequest requestBody)
        {
            var request = new HttpRequestMessage(HttpMethod.Post, "https://api.clearlydefined.io/notices")
            {
                Content = JsonContent.Create(requestBody)
            };

            Console.WriteLine($"{request.Method.ToString().ToUpperInvariant()} {request.RequestUri}");
            var response = await client.SendAsync(request) ?? throw new ApplicationException("Null response was received.");
            Console.WriteLine($"  {response.StatusCode}");
            foreach (var header in response.Headers)
            {
                Console.WriteLine($"  {header.Key}: {string.Join("; ", header.Value)}");
            }

            if (response.StatusCode != HttpStatusCode.OK)
            {
                var error = await response.Content.ReadAsStringAsync();
                throw new ApplicationException(error);
            }

            var responseBody = await response.Content.ReadFromJsonAsync<NoticeResponse>(SerializerOptions) ?? throw new Exception("Unable to deserialize response.");

            // strip out large content before logging out the response
            var responseForLogging = JsonSerializer.Serialize(responseBody with { Content = "..." }, SerializerOptions);
            Console.WriteLine(responseForLogging);

            return responseBody;
        }
    }
}
